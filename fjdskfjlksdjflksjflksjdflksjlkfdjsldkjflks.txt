from datetime import datetime, timedelta
import csv
import os
import re
import time
import requests
from time import sleep
from aiogram import Bot, Dispatcher, types
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update, Bot, ParseMode, ForceReply
from telegram.error import BadRequest
from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, MessageHandler, Filters, ConversationHandler
from colorama import init, Fore
from filelock import Timeout, FileLock
import httpx
import tweeterid
import concurrent.futures

CSV_LOCK = "users_data.lock"
TOKENS_LOCK = "tokens.lock"
TOKEN = '6375640441:AAEPr7vYvmAXErdi54FT5ODkWDw1-So7Pac'
API_KEY = "2IGT2KJVE3S3ADQ79QXXDDTDBVAPUKW1E4"
ETH_PRICE_API_URL = f"https://api.etherscan.io/api?module=stats&action=ethprice&apikey={API_KEY}"
TARGET_ADDRESS = "0xaE79dCA03921BeA00AADE829bfe097a881f53822"
TOKEN_QTY = 0
TOKEN_CONFIRM = 1
LIKE_TWEETID = 2
LIKE_THREADCOUNT = 3
LIKE_LIKELIMIT = 4
RETWEET_TWEETID = 5
RETWEET_THREADCOUNT = 6
RETWEET_RETWEETLIMIT = 7
FOLLOW_USERNAME = 8
FOLLOW_THREADCOUNT = 9
FOLLOW_LIMIT = 10
MANUAL_USER_ID_INPUT = 11
CREDITS_INFO_STATE = 20
LIKE_CONFIRM = 100
RETWEET_CONFIRM = 101
FOLLOW_CONFIRM = 103
CRACKED_TOKEN_PRICE_CREDITS = 1.5
LIKE_COST = 0.035
RETWEET_COST = 0.035
FOLLOW_COST = 0.05
MANUAL_USER_ID = range(80)  # Assuming 8 is the next available number
CSV_FILE = 'users_data.csv'
WHITELISTED_USER_IDS = [6155069591, 2082943997, 5677756468]
tokens_lock = FileLock(TOKENS_LOCK, timeout=10)
lock = FileLock(CSV_LOCK, timeout=10)

def restock(update, context):
    user_id = update.message.from_user.id
    if user_id not in WHITELISTED_USER_IDS:
        update.message.reply_text("ğŸš« Sorry, you're not authorized to restock! ğŸš«")
        return
    update.message.reply_text("ğŸ“¥ Please send me the `.txt` file with the new tokens you'd like to add to our stock ğŸ”„")
        
    
def send_followers(update, context, target_username, delay, thread_count, follow_limit, target_user_id=None):
    init(autoreset=True)
    tokens = open("tokens.txt", "r").read().splitlines()[:follow_limit]
    proxies_list = open("proxies.txt", "r").readlines()
    print(f"{Fore.YELLOW}\n[!] Loaded {len(tokens)} tokens.{Fore.RESET}\n")
    if not target_user_id:
        try:
            target_user_id = tweeterid.handle_to_id(target_username)
        except ValueError:
            query = update.callback_query
            query.message.reply_text(
                "ğŸ˜… Oops! We ran into a snag converting the username to a user ID. "
                "No worries, though! Please head over to [TweeterID](https://tweeterid.com) "
                "to manually get the user ID and then share it with us here. Thanks! ğŸ™Œ",
                parse_mode=ParseMode.MARKDOWN)
            return MANUAL_USER_ID_INPUT
    def follow(token, target_username):
        try:
            proxy = proxies_list[tokens.index(token) % len(proxies_list)].strip()
            proxies = {"http://": proxy, "https://": proxy}
            session = httpx.Client(http2=True, proxies=proxies)
            cookies = {'auth_token': token}
            headers = {
                'authority': 'twitter.com',
                'accept': '*/*',
                'accept-language': 'en-US,en;q=0.9',
                'authorization': 'Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA',
                'origin': 'https://twitter.com',
                'referer': f'https://twitter.com/{target_username}',
                'sec-fetch-dest': 'empty',
                'sec-fetch-mode': 'cors',
                'sec-fetch-site': 'same-origin',
                'sec-gpc': '1',
                'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5024.121 Safari/537.36',
                'x-twitter-active-user': 'yes',
                'x-twitter-auth-type': 'OAuth2Session',
                'x-twitter-client-language': 'en'}
            ct0_response = session.post('https://twitter.com/i/api/1.1/account/update_profile.json', cookies=cookies, headers=headers)
            ct0 = ct0_response.cookies['ct0']
            cookies['ct0'] = ct0
            headers['x-csrf-token'] = ct0
            if ct0_response.status_code != 401:
                data = {
                    'include_profile_interstitial_type': '1',
                    'include_blocking': '1',
                    'include_blocked_by': '1',
                    'include_followed_by': '1',
                    'include_want_retweets': '1',
                    'include_mute_edge': '1',
                    'include_can_dm': '1',
                    'include_can_media_tag': '1',
                    'include_ext_has_nft_avatar': '1',
                    'skip_status': '1',
                    'user_id': target_user_id,}
                response = session.post('https://twitter.com/i/api/1.1/friendships/create.json', cookies=cookies, headers=headers, data=data, timeout=10)
                if response.status_code == 200:
                    print(f"{Fore.GREEN}[+] {token} added Follow!{Fore.RESET}")
                else:
                    print(f"{Fore.RED}[!] {token} failed to add Follow.{Fore.RESET}")
            else:
                print(f"{Fore.RED}[!] {token} is not authenticated.{Fore.RESET}")
        except Exception as err:
            print(f"{Fore.RED}[!] Error for {token}: {err}{Fore.RESET}")
            pass
    with concurrent.futures.ThreadPoolExecutor(max_workers=thread_count) as executor:
        for token in tokens:
            executor.submit(follow, token, target_username)
            sleep(delay)
    
def manual_user_id_input(update, context):
    user_id = update.message.text
    return send_followers(update, context, context.user_data['target_username'], context.user_data['delay'], context.user_data['thread_count'], context.user_data['follow_limit'], target_user_id=user_id)
    
    
def follow_start(update, context):
    keyboard = [
        [InlineKeyboardButton("âŒ Cancel", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.callback_query.edit_message_text(
        "ğŸ‘¤ Please enter the *Username* you'd like to send followers to:",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN)
    return FOLLOW_USERNAME


def follow_username(update, context):
    context.user_data['target_username'] = update.message.text
    keyboard = [
        [InlineKeyboardButton("âŒ Cancel", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text(
        f"ğŸ‘¤ You've chosen Username: *{context.user_data['target_username']}* \n\n"
        "Please specify the number of threads you'd like to use for sending followers:",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN)
    return FOLLOW_THREADCOUNT


def follow_threadcount(update, context):
    context.user_data['thread_count'] = int(update.message.text)
    context.user_data['delay'] = 0 
    keyboard = [
        [InlineKeyboardButton("âŒ Cancel", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text(
        f"ğŸš€ You've set the thread count to: *{context.user_data['thread_count']}* \n\n"
        "Now, please specify the number of followers you'd like to send:",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN)
    return FOLLOW_LIMIT


def follow_limit(update, context):
    user_id = update.message.from_user.id
    user_data = get_user_by_telegram_id(user_id)
    credits = user_data['Credits']
    context.user_data['follow_limit'] = int(update.message.text)
    available = available_tokens()
    if context.user_data['follow_limit'] > available:
        update.message.reply_text(f"ğŸš« Sorry, we currently have only {available} tokens available. ğŸ“‰ Please select a follower count below or equal to this number. ğŸ™")
        return FOLLOW_LIMIT
    cost_in_credits = context.user_data['follow_limit'] * FOLLOW_COST
    if credits < cost_in_credits:
        keyboard = [
            [InlineKeyboardButton("ğŸ’³ Top Up Credits", callback_data="top_up_credits"),
             InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            f"----------âŒ Insufficient Credits âŒ----------\n\nğŸ’° You need {cost_in_credits} credits for this action but currently have only {credits} credits.\n\nğŸ” Please top up your credits to continue.",
            reply_markup=reply_markup)
        return FOLLOW_LIMIT
    try:
        target_user_id = tweeterid.handle_to_id(context.user_data['target_username'])
    except ValueError:
        update.message.reply_text(
            "ğŸ˜… Oops! We ran into a snag converting the username to a user ID. No worries, though! Please head over to [TweeterID](https://tweeterid.com) to manually get the user ID and then share it with us here. Thanks! ğŸ™Œ",
            parse_mode=ParseMode.MARKDOWN)
        return MANUAL_USER_ID_INPUT
    remaining_credits = credits - cost_in_credits
    keyboard = [
        [InlineKeyboardButton("âœ… Yes", callback_data="confirm_follow"),
         InlineKeyboardButton("âŒ No", callback_data="cancel_action")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text(
        f"--------ğŸ›ï¸ Purchase Confirmation ğŸ›ï¸--------\n\n"
        f"ğŸ‘¥ Are you sure you want to send {context.user_data['follow_limit']} followers for {cost_in_credits} credits?\n\n"
        f"ğŸ’° Your remaining account balance would be {remaining_credits} credits.",
        reply_markup=reply_markup)
    return FOLLOW_CONFIRM


def send_retweets(tweet_id, delay, thread_count, retweet_limit):
    init(autoreset=True)
    tokens = open("tokens.txt", "r").read().splitlines()[:retweet_limit]
    proxies_list = open("proxies.txt", "r").readlines()
    print(f"{Fore.YELLOW}\n[!] Loaded {len(tokens)} tokens.{Fore.RESET}\n")
    def retweet(token, tweet_id):
        try:
            proxy = proxies_list[tokens.index(token) % len(proxies_list)].strip()
            proxies = {"http://": proxy, "https://": proxy}
            session = httpx.Client(http2=True, proxies=proxies)
            cookies = {'auth_token': token}
            headers = {
                'authority': 'twitter.com',
                'accept': '*/*',
                'accept-language': 'en-US,en;q=0.9',
                'authorization': 'Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA',
                'origin': 'https://twitter.com',
                'referer': 'https://twitter.com/home',
                'sec-fetch-dest': 'empty',
                'sec-fetch-mode': 'cors',
                'sec-fetch-site': 'same-origin',
                'sec-gpc': '1',
                'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5024.121 Safari/537.36',
                'x-twitter-active-user': 'yes',
                'x-twitter-auth-type': 'OAuth2Session',
                'x-twitter-client-language': 'en'}
            ct0_response = session.post('https://twitter.com/i/api/1.1/account/update_profile.json', cookies=cookies, headers=headers)
            ct0 = ct0_response.cookies['ct0']
            cookies['ct0'] = ct0
            headers['x-csrf-token'] = ct0
            if ct0_response.status_code != 401:
                payload = {
                    'variables': {
                        'tweet_id': tweet_id,
                        'dark_request': False,},
                    'queryId': 'ojPdsZsimiJrUGLR1sjUtA',}
                response = session.post('https://twitter.com/i/api/graphql/ojPdsZsimiJrUGLR1sjUtA/CreateRetweet', cookies=cookies, headers=headers, json=payload, timeout=20)
                if response.status_code == 200:
                    print(f"{Fore.GREEN}[+] {token} added Retweet!{Fore.RESET}")
                else:
                    print(f"{Fore.RED}[!] {token} failed to add Retweet.{Fore.RESET}")
        except Exception as err:
            print(f"{Fore.RED}[!] Error for {token}: {err}{Fore.RESET}")
            pass
    with concurrent.futures.ThreadPoolExecutor(max_workers=thread_count) as executor:
        for token in tokens:
            executor.submit(retweet, token, tweet_id)
            sleep(delay)


def retweet_start(update, context):
    keyboard = [
        [InlineKeyboardButton("âŒ Cancel", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.callback_query.edit_message_text(
        "ğŸ¦ Please enter the *Tweet ID* you'd like to send retweets to:",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN)
    return RETWEET_TWEETID


def retweet_tweetid(update, context):
    context.user_data['tweet_id'] = update.message.text
    keyboard = [
        [InlineKeyboardButton("âŒ Cancel", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text(
        f"ğŸ¦ You've chosen Tweet ID: *{context.user_data['tweet_id']}* \n\n"
        "Please specify the number of threads you'd like to use for sending retweets:",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN)
    return RETWEET_THREADCOUNT


def retweet_threadcount(update, context):
    context.user_data['thread_count'] = int(update.message.text)
    context.user_data['delay'] = 0
    keyboard = [
        [InlineKeyboardButton("âŒ Cancel", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text(
        f"ğŸš€ You've set the thread count to: *{context.user_data['thread_count']}* \n\n"
        "Now, please specify the number of retweets you'd like to send to the tweet:",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN)
    return RETWEET_RETWEETLIMIT


def retweet_retweetlimit(update, context):
    user_id = update.message.from_user.id
    user_data = get_user_by_telegram_id(user_id)
    credits = user_data['Credits']
    context.user_data['retweet_limit'] = int(update.message.text)
    available = available_tokens()
    if context.user_data['retweet_limit'] > available:
        update.message.reply_text(f"ğŸš« Sorry, we currently have only {available} tokens available. ğŸ“‰ Please select a retweet count below or equal to this number. ğŸ™")
        return RETWEET_RETWEETLIMIT
    cost_in_credits = context.user_data['retweet_limit'] * RETWEET_COST
    if credits < cost_in_credits:
        keyboard = [
            [InlineKeyboardButton("ğŸ’³ Top Up Credits", callback_data="top_up_credits"),
             InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            f"----------âŒ Insufficient Credits âŒ----------\n\nğŸ’° You need {cost_in_credits} credits for this action but currently have only {credits} credits.\n\nğŸ” Please top up your credits to continue.",
            reply_markup=reply_markup)
        return RETWEET_RETWEETLIMIT
    else:
        remaining_credits = credits - cost_in_credits
        keyboard = [
            [InlineKeyboardButton("âœ… Yes", callback_data="confirm_retweet"),
             InlineKeyboardButton("âŒ No", callback_data="cancel_action")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            f"--------ğŸ›ï¸ Purchase Confirmation ğŸ›ï¸--------\n\n"
            f"ğŸ”— Are you sure you want to send {context.user_data['retweet_limit']} retweets for {cost_in_credits} credits?\n\n"
            f"ğŸ’° Your remaining account balance would be {remaining_credits} credits.",
            reply_markup=reply_markup)
        return RETWEET_CONFIRM


def send_likes(tweet_id, delay, thread_count, like_limit):
    init(autoreset=True)
    tokens = open("tokens.txt", "r").read().splitlines()[:like_limit]
    proxies_list = open("proxies.txt", "r").readlines()
    print(f"{Fore.YELLOW}\n[!] Loaded {len(tokens)} tokens.{Fore.RESET}\n")
    def like(token, tweet_id):
        try:
            proxy = proxies_list[tokens.index(token) % len(proxies_list)].strip()
            proxies = {"http://": proxy, "https://": proxy}
            session = httpx.Client(http2=True, proxies=proxies)
            cookies = {'auth_token': token}
            headers = {
            'authority': 'twitter.com',
            'accept': '*/*',
            'accept-language': 'en-US,en;q=0.9',
            'authorization': 'Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA',
            'origin': 'https://twitter.com',
            'referer': 'https://twitter.com/home',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'same-origin',
            'sec-gpc': '1',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5024.121 Safari/537.36',
            'x-twitter-active-user': 'yes',
            'x-twitter-auth-type': 'OAuth2Session',
            'x-twitter-client-language': 'en'}
            ct0_response = session.post('https://twitter.com/i/api/1.1/account/update_profile.json', cookies=cookies, headers=headers)
            ct0 = ct0_response.cookies['ct0']
            cookies['ct0'] = ct0
            headers['x-csrf-token'] = ct0
            if ct0_response.status_code != 401:
                payload = {
                    'variables': {
                        'tweet_id': tweet_id,
                    },
                    'queryId': 'lI07N6Otwv1PhnEgXILM7A',}
                response = session.post('https://twitter.com/i/api/graphql/lI07N6Otwv1PhnEgXILM7A/FavoriteTweet', cookies=cookies, headers=headers, json=payload, timeout=20)
                if response.status_code == 200:
                    print(f"{Fore.GREEN}[+] {token} added Like!{Fore.RESET}")
                else:
                    print(f"{Fore.RED}[!] {token} failed to add Like.{Fore.RESET}")
        except Exception as err:
            print(f"{Fore.RED}[!] Error for {token}: {err}{Fore.RESET}")
            pass
    with concurrent.futures.ThreadPoolExecutor(max_workers=thread_count) as executor:
        for token in tokens:
            executor.submit(like, token, tweet_id)
            sleep(delay)
            
            
def like_start(update, context):
    keyboard = [
        [InlineKeyboardButton("âŒ Cancel", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.callback_query.edit_message_text(
        "ğŸ¦ Please enter the *Tweet ID* you'd like to send likes to:",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN)
    return LIKE_TWEETID


def like_tweetid(update, context):
    context.user_data['tweet_id'] = update.message.text
    keyboard = [
        [InlineKeyboardButton("âŒ Cancel", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text(
        f"ğŸ¦ You've chosen Tweet ID: *{context.user_data['tweet_id']}* \n\n"
        "Please specify the number of threads you'd like to use for sending likes:",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN)
    return LIKE_THREADCOUNT


def like_threadcount(update, context):
    context.user_data['thread_count'] = int(update.message.text)
    context.user_data['delay'] = 0
    keyboard = [
        [InlineKeyboardButton("âŒ Cancel", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text(
        f"ğŸš€ You've set the thread count to: *{context.user_data['thread_count']}* \n\n"
        "Now, please specify the number of likes you'd like to send to the tweet:",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN)
    return LIKE_LIKELIMIT 


def like_likelimit(update, context):
    user_id = update.message.from_user.id
    user_data = get_user_by_telegram_id(user_id)
    credits = user_data['Credits']
    context.user_data['like_limit'] = int(update.message.text)
    available = available_tokens()
    if context.user_data['like_limit'] > available:
        update.message.reply_text(f"ğŸš« Sorry, we currently have only {available} tokens available. ğŸ“‰ Please select a like count below or equal to this number. ğŸ™")
        return LIKE_LIKELIMIT
    cost_in_credits = context.user_data['like_limit'] * LIKE_COST
    if credits < cost_in_credits:
        keyboard = [
            [InlineKeyboardButton("ğŸ’³ Top Up Credits", callback_data="top_up_credits"),
             InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            f"----------âŒ Insufficient Credits âŒ----------\n\nğŸ’° You need {cost_in_credits} credits for this action but currently have only {credits} credits.\n\nğŸ” Please top up your credits to continue.",
            reply_markup=reply_markup)
        return LIKE_LIKELIMIT
    else:
        remaining_credits = credits - cost_in_credits
        keyboard = [
            [InlineKeyboardButton("âœ… Yes", callback_data="confirm_like"),
             InlineKeyboardButton("âŒ No", callback_data="cancel_action")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            f"--------ğŸ›ï¸ Purchase Confirmation ğŸ›ï¸--------\n\n"
            f"ğŸ”— Are you sure you want to send {context.user_data['like_limit']} likes for {cost_in_credits} credits?\n\n"
            f"ğŸ’° Your remaining account balance would be {remaining_credits} credits.",
            reply_markup=reply_markup)
        return LIKE_CONFIRM 

    
def handle_document(update, context):
    user_id = update.message.from_user.id
    if user_id not in WHITELISTED_USER_IDS:
        update.message.reply_text("ğŸš« Sorry, you're not authorized to perform this action! ğŸ›‘")
        return
    file = context.bot.getFile(update.message.document.file_id)
    file.download('new_tokens.txt')
    with open('new_tokens.txt', 'r') as new_tokens_file:
        new_tokens = new_tokens_file.readlines()
    with open('tokens.txt', 'a') as tokens_file:
        tokens_file.writelines(new_tokens)
    os.remove('new_tokens.txt')
    with open('tokens.txt', 'r') as tokens_file:
        total_tokens = len(tokens_file.readlines())
    update.message.reply_text(f"ğŸ‰ Successfully added {len(new_tokens)} new tokens! ğŸ”„ Current total: {total_tokens} tokens ğŸ‰")


def save_new_user(user_id, username):
    with lock:
        with open('users_data.csv', 'a', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow([user_id, username, 0.0])

def user_exists(user_id):
    with lock:
        with open('users_data.csv', 'r', newline='') as csvfile:
            reader = csv.reader(csvfile)
            next(reader, None)
            for row in reader:
                if int(row[0]) == user_id:
                    return True
        return False

def get_user_by_telegram_id(user_id):
    with lock:
        with open('users_data.csv', 'r') as csvfile:
            reader = csv.reader(csvfile)
            next(reader)
            for row in reader:
                if int(row[0]) == user_id:
                    return {'UserID': int(row[0]), 'Username': row[1], 'Credits': float(row[2])}
        return None

def available_tokens():
    with tokens_lock:
        with open('tokens.txt', 'r') as f:
            return len(f.readlines())

def deduct_credits(user_id, amount):
    with lock:
        with open(CSV_FILE, 'r') as file:
            lines = file.readlines()
        with open(CSV_FILE, 'w') as file:
            for line in lines:
                if str(user_id) in line:
                    data = line.strip().split(',')
                    current_credits = float(data[2])
                    current_credits -= amount
                    file.write(f"{data[0]},{data[1]},{current_credits}\n")
                else:
                    file.write(line)

def start(update, context):
    user_id = update.message.from_user.id
    username = update.message.from_user.username
    with lock:
        if not os.path.exists(CSV_FILE):
            with open(CSV_FILE, mode='w', newline='') as file:
                writer = csv.writer(file)
                writer.writerow(['UserID', 'Username', 'Credits'])
        if not user_exists(user_id):
            save_new_user(user_id, username)
        services(update, context)


def services(update, context):
    user_id = update.message.from_user.id if update.message else update.callback_query.from_user.id
    user_data = get_user_by_telegram_id(user_id)
    credits = float(user_data['Credits'])
    reply_markup = InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ‘ Likes", callback_data="like"), InlineKeyboardButton("ğŸ” Retweets", callback_data="retweet")],
        [InlineKeyboardButton("ğŸ‘¥ Followers", callback_data="follow"), InlineKeyboardButton("ğŸ’¬ Replies", callback_data="replies")],
        [InlineKeyboardButton("ğŸ¦ Purchase Twitter Tokens ğŸ¦", callback_data="token_choice")]])
    description = (
    f"----------ğŸ›ï¸ **Services Overview** ğŸ›ï¸----------\n\n"
    "Our **Twitter Engagement Panel** offers a suite of tools designed to enhance your social media presence:\n\n"
    "- **ğŸ‘ `Likes`**: Boost the popularity of any tweet with as many likes as you desire.\n\n"
    "- **ğŸ” `Retweets`**: Amplify your message by adding retweets to your content.\n\n"
    "- **ğŸ‘¥ `Followers`**: Grow your audience by adding followers to any Twitter account.\n\n"
    "- **ğŸ’¬ `Replies`**: Engage further by sending custom or generic replies beneath any tweet.\n\n"
    f"ğŸ’° Current Credits: {credits}\n"
    "ğŸ›ï¸ Which service would you like to use?")
    if update.message:
        context.bot.send_message(chat_id=update.message.chat_id, text=description, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    else:
        update.callback_query.edit_message_text(text=description, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)


def purchase_tokens_choice(update, context):
    keyboard = [
        [InlineKeyboardButton("ğŸ’¥ Cracked", callback_data="cracked_choice")],
        [InlineKeyboardButton("âœ‰ï¸ Email Verified (Coming Soon)", callback_data="evgen_choice")],
        [InlineKeyboardButton("ğŸ”’ Full Verified (Coming Soon)", callback_data="fvgen_choice")],
        [InlineKeyboardButton("ğŸ”™ Back", callback_data="back_to_main")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    price_list = (
       "----------ğŸª™ <b>Token Price List</b> ğŸª™----------\n\n"
        "ğŸ’¥ Cracked: $0.15 per token\n\n"
        "<s>âœ‰ï¸ Email Verified: $0.10 per token</s>\n"
        "<s>ğŸ”’ Full Verified: $0.25 per token</s>\n\n"
        "Select the token type you wish to purchase:")
    update.callback_query.edit_message_text(text=price_list, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
    update.callback_query.answer()


def add_credits(user_id, credits_to_add):
    with lock:
        with open('users_data.csv', 'r') as file:
            lines = file.readlines()
        with open('users_data.csv', 'w') as file:
            for line in lines:
                data = line.strip().split(',')
                if str(user_id) == data[0]:
                    current_credits = float(data[2])
                    current_credits += credits_to_add
                    file.write(f"{data[0]},{data[1]},{current_credits}\n")
                else:
                    file.write(line)


def handle_callback(update, context):
    query_data = update.callback_query.data
    update.callback_query.answer() 
    user_id = update.callback_query.from_user.id
    if query_data == "waiting":
        update.callback_query.answer("Please wait...")
        return ConversationHandler.END
    user_data = get_user_by_telegram_id(user_id)
    credits = user_data['Credits']
    cost_in_credits = 0
    if query_data == "confirm_purchase":
        qty = context.user_data['qty_to_purchase']
        available = available_tokens()
        cost_in_credits = qty * CRACKED_TOKEN_PRICE_CREDITS
        if qty > available:
            keyboard = [
                [InlineKeyboardButton("ğŸ”¢ Enter New Amount", callback_data="enter_new_amount"),
                 InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            update.callback_query.edit_message_text(
                f"ğŸš« Oops! Looks like someone beat you to it. We now have only {available} tokens in stock.\n\nğŸ”„ Please request a smaller quantity or try again later.",
                reply_markup=reply_markup)
            return TOKEN_QTY
        tokens_to_send = extract_tokens(qty)
        filename = f"{user_id}_{qty}.txt"
        with open(filename, 'w') as f:
            f.writelines(tokens_to_send)
        with open(filename, 'rb') as f:
            context.bot.send_document(chat_id=user_id, document=f, filename=filename)
        os.remove(filename)
        deduct_credits(user_id, cost_in_credits)
        keyboard = [[InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.callback_query.edit_message_text(
            f"--------------ğŸ‰ Success! ğŸ‰--------------\n\nğŸ”— We've sent you {qty} tokens as a file attachment.\n\nğŸ’° {cost_in_credits} credits have been deducted from your account. Thank you for your purchase! ğŸ›ï¸",
            reply_markup=reply_markup)
        return ConversationHandler.END
    elif query_data == "cancel_purchase":
        keyboard = [[InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.callback_query.edit_message_text(
            "---------ğŸš« Purchase Canceled ğŸš«---------\n\n",
            reply_markup=reply_markup)
        return ConversationHandler.END
    if query_data in ["cracked_choice", "evgen_choice", "fvgen_choice"] and credits <= 0:
        keyboard = [
            [InlineKeyboardButton("ğŸ’³ Top Up Credits", callback_data="top_up_credits"),
             InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.callback_query.edit_message_text(
            "âŒ Oops! You have 0 credits. ğŸ’³ Please top up to continue. ğŸ”",
            reply_markup=reply_markup)
        return ConversationHandler.END
    if query_data == "enter_new_amount":
        update.callback_query.edit_message_text("ğŸ”¢ Please enter the new amount of tokens you'd like to purchase: ğŸ›’")
    elif query_data == "top_up_credits":
        BuyCredits(update, context)
        return ConversationHandler.END
    elif query_data == "handle_purchase":
        handle_purchase_callback(update, context)
        return ConversationHandler.END
    elif query_data == "main_menu":
        services(update, context)
        return ConversationHandler.END
    elif query_data == "back_to_main":
        services(update, context)
        return ConversationHandler.END
    elif query_data == "like":
        cost_in_credits = context.user_data.get('like_limit', 0) * LIKE_COST
        if credits < cost_in_credits:
            keyboard = [
                [InlineKeyboardButton("ğŸ’³ Top Up Credits", callback_data="top_up_credits"),
                 InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            update.callback_query.edit_message_text(
                f"----------âŒ Insufficient Credits âŒ----------\n\nğŸ’° You need {cost_in_credits} credits for this action but currently have only {credits} credits.\n\nğŸ” Please top up your credits to continue.",
                reply_markup=reply_markup)
            return LIKE_LIKELIMIT
        else:
            like_conv.entry_points[0].callback(update, context)
            return LIKE_TWEETID
    elif query_data == "retweet":
        retweet_conv.entry_points[0].callback(update, context)
        return RETWEET_TWEETID
    elif query_data == "follow":
        follow_conv.entry_points[0].callback(update, context)
        return FOLLOW_USERNAME
    elif query_data == "replies":
        update.callback_query.edit_message_text("ğŸš§ğŸ”§ Sorry, this feature is currently under maintenance! Please check back later. ğŸ”§ğŸš§")
        return ConversationHandler.END
    elif query_data == "credits":
        update.callback_query.edit_message_text("ğŸ’³ You chose to Top Up!")
        return ConversationHandler.END
    elif query_data == "token_choice":
        purchase_tokens_choice(update, context)
        return ConversationHandler.END
    elif query_data == "cracked_choice":
        purchase_tokens(update, context)
        return ConversationHandler.END
    elif query_data == "confirm_like":
        cost_in_credits = context.user_data['like_limit'] * LIKE_COST
        if credits >= cost_in_credits:
            message_text = f"ğŸ‘ Alright! Preparing to send *{context.user_data['like_limit']}* likes to Tweet ID: *{context.user_data['tweet_id']}*"
            wait_markup = InlineKeyboardMarkup([[InlineKeyboardButton("â³ Please wait...", callback_data="waiting")]])
            context.bot.send_message(chat_id=user_id, text=message_text, parse_mode=ParseMode.MARKDOWN, reply_markup=wait_markup)
        deduct_credits(user_id, cost_in_credits)
        send_likes(context.user_data['tweet_id'], context.user_data['delay'], context.user_data['thread_count'], context.user_data['like_limit'])
        keyboard = [[InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        context.bot.send_message(chat_id=user_id,
            text=f"âœ… Process completed!\n\nSuccessfully sent *{context.user_data['like_limit']}* likes to Tweet:\nhttps://twitter.com/done/status/{context.user_data['tweet_id']} ğŸ‰",
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup)
        return ConversationHandler.END
    if query_data == "cancel_action":
        reply_markup = InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]])
        update.callback_query.edit_message_text("---------ğŸš« Purchase Canceled ğŸš«---------\n\nYour credits have not been deducted.", reply_markup=reply_markup)
        return ConversationHandler.END
    elif query_data == "confirm_retweet":
        cost_in_credits = context.user_data['retweet_limit'] * RETWEET_COST
        if credits >= cost_in_credits:
            deduct_credits(user_id, cost_in_credits)
            message_text = f"ğŸ”„ Alright! Preparing to send *{context.user_data.get('retweet_limit', 'N/A')}* retweets to Tweet ID: *{context.user_data.get('tweet_id', 'N/A')}*"
            wait_markup = InlineKeyboardMarkup([[InlineKeyboardButton("â³ Please wait...", callback_data="waiting")]])
            context.bot.send_message(chat_id=user_id, text=message_text, parse_mode=ParseMode.MARKDOWN, reply_markup=wait_markup)
            send_retweets(context.user_data['tweet_id'], context.user_data['delay'], context.user_data['thread_count'], context.user_data['retweet_limit'])
            keyboard = [[InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            context.bot.send_message(chat_id=user_id,
                                    text=f"âœ… Process completed! Successfully sent *{context.user_data['retweet_limit']}* retweets to Tweet:\nhttps://twitter.com/done/status/{context.user_data['tweet_id']} ğŸ‰",
                                    parse_mode=ParseMode.MARKDOWN,
                                    reply_markup=reply_markup)
            return ConversationHandler.END
        else:
            keyboard = [
                [InlineKeyboardButton("ğŸ’³ Top Up Credits", callback_data="top_up_credits"),
                InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            update.callback_query.edit_message_text(
                f"----------âŒ Insufficient Credits âŒ----------\n\nğŸ’° You need {cost_in_credits} credits for this action but currently have only {credits} credits.\n\nğŸ” Please top up your credits to continue.",
                reply_markup=reply_markup)
            return RETWEET_RETWEETLIMIT
    elif query_data == "confirm_follow":
        cost_in_credits = context.user_data['follow_limit'] * FOLLOW_COST
        if credits >= cost_in_credits:
            deduct_credits(user_id, cost_in_credits)
            message_text = f"ğŸ‘¥ Alright! Preparing to send *{context.user_data.get('follow_limit', 'N/A')}* followers to Username: *{context.user_data.get('target_username', 'N/A')}*"
            wait_markup = InlineKeyboardMarkup([[InlineKeyboardButton("â³ Please wait...", callback_data="waiting")]])
            context.bot.send_message(chat_id=user_id, text=message_text, parse_mode=ParseMode.MARKDOWN, reply_markup=wait_markup)
            send_followers(update, context, context.user_data['target_username'], context.user_data['delay'], context.user_data['thread_count'], context.user_data['follow_limit'])
            keyboard = [[InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            context.bot.send_message(chat_id=user_id,
                                    text=f"âœ… Process completed! Successfully sent *{context.user_data['follow_limit']}* followers to: https://twitter.com/{context.user_data['target_username']} ğŸ‰",
                                    parse_mode=ParseMode.MARKDOWN,
                                    reply_markup=reply_markup)
            return ConversationHandler.END
        else:
            keyboard = [
                [InlineKeyboardButton("ğŸ’³ Top Up Credits", callback_data="top_up_credits"),
                InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            update.callback_query.edit_message_text(
                f"----------âŒ Insufficient Credits âŒ----------\n\nğŸ’° You need {cost_in_credits} credits for this action but currently have only {credits} credits.\n\nğŸ” Please top up your credits to continue.",
                reply_markup=reply_markup)
            return FOLLOW_LIMIT
  

def your_confirm_function(update, context):
    user_id = update.callback_query.from_user.id
    user_data = get_user_by_telegram_id(user_id)
    credits = user_data['Credits']
    cost_in_credits = context.user_data['like_limit'] * LIKE_COST
    deduct_credits(user_id, cost_in_credits)
    send_likes(context.user_data['tweet_id'], context.user_data['delay'], context.user_data['thread_count'], context.user_data['like_limit'])
    keyboard = [[InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.callback_query.edit_message_text(
        f"âœ… Process completed!\n\nSuccessfully sent *{context.user_data['like_limit']}* likes to Tweet:\nhttps://twitter.com/done/status/{context.user_data['tweet_id']} ğŸ‰",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup)
    return ConversationHandler.END


def your_cancel_function(update, context):
    update.callback_query.edit_message_text("ğŸš« Action Canceled ğŸš«")
    return ConversationHandler.END


def BuyCredits(update, context):
    chat_id = update.effective_chat.id
    keyboard = [
        [InlineKeyboardButton("ğŸ’³ Buy Credits Now!", callback_data="handle_purchase")],
        [InlineKeyboardButton("â“ How Credits Work", callback_data="credits_info")],
        [InlineKeyboardButton("ğŸ”™ Back", callback_data="main_menu")] ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    message_text = (
        "-----ğŸŒŸ *Elevate Your Twitter Game!* ğŸŒŸ-----\n\n"
        "By purchasing credits, you unlock the door to our *premium services*:\n\n"
        "ğŸ‘ Instant Likes\n"
        "ğŸ”„ Swift Retweets\n"
        "ğŸ‘¥ New Followers\n"
        "ğŸ”‘ Exclusive Twitter Tokens\n\n"
        "Boost your Twitter presence in a snap and stand out in the crowd! ğŸŒâœ¨\n\n"
        "ğŸ *Bonus Tip:* Keep an eye out for our special offers to grab bonus credits! ğŸ’ğŸ’°")
    if update.callback_query:
        update.callback_query.edit_message_text(text=message_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    else:
        context.bot.send_message(chat_id=chat_id, text=message_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)


def handle_purchase_callback(update, context):
    print("Entered handle_purchase_callback")
    query = update.callback_query
    query.answer()
    context.user_data['awaiting_amount'] = True
    message_text = (
        "----------ğŸ’° *Credit Purchase* ğŸ’°----------\n"
        "Each credit costs $0.10\nThis means:\n\n"
        "- $1 = 10 credits\n"
        "- $10 = 100 credits\n"
        "- $50 = 500 credits\n\n"
        "Please type the *USD amount* you'd like to deposit for credits. For instance, type `10` for $10 worth of credits.\n\n"
    )
    keyboard = [[InlineKeyboardButton("ğŸš« Cancel Purchase", callback_data='cancel_purchase')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    query.edit_message_text(text=message_text, reply_markup=reply_markup, parse_mode='Markdown')

    
def handle_user_response(update, context):
    print("Entered handle_user_response")
    user_id = update.message.from_user.id
    if context.user_data.get('awaiting_amount'):
        try:
            dollar_amount = float(update.message.text.replace('$', '').strip())
            eth_amount = get_payment_amount_in_eth(dollar_amount, user_id)
            if eth_amount:
                context.user_data['expected_eth_amount'] = eth_amount
                context.user_data['dollar_amount'] = dollar_amount
                keyboard = [
                    [InlineKeyboardButton("ğŸ”„ Check Payment", callback_data='checkpayment')],
                    [InlineKeyboardButton("â“ How it works", callback_data='credits_info')],
                    [InlineKeyboardButton("ğŸš« Cancel", callback_data='cancel_purchase')]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                message_text = (
                    f"ğŸ‘Œ Great! Please make a payment with the details below:\n\n"
                    f"ğŸ’² Amount: `{eth_amount}` ETH\n\n"
                    f"ğŸ”— Address: `{TARGET_ADDRESS}`\n\n"
                    f"â³ You have 30 minutes to complete the transaction. "
                    f"Once done, you can use the 'Check Payment' button below to confirm your transaction."
                )
                update.message.reply_text(message_text, reply_markup=reply_markup, parse_mode='Markdown')
            else:
                update.message.reply_text("âŒ Oops! There was an error calculating the ETH amount. Please try again.")
        except ValueError:
            update.message.reply_text("âŒ Oops! Please enter a valid amount in USD. Examples: `10`, `$10`, or `$10.00`.")
        del context.user_data['awaiting_amount']  # Clear the flag
        return ConversationHandler.END
    
    
def check_payment_callback(update, context):
    print("Entered check_payment_callback")
    query = update.callback_query
    user_id = query.from_user.id
    eth_amount = context.user_data.get('expected_eth_amount')
    try:
        query.answer(text="Checking for payment, please wait...")
    except BadRequest:
        print("Error: Callback query too old or already answered.")
        return
    if monitor_for_transaction(eth_amount, duration_seconds=15):
        credits_added = int(context.user_data.get('dollar_amount') * 10)
        add_credits(user_id, credits_added)
        new_message = f"ğŸ‰ Payment detected! {credits_added} credits have been added to your account. Thank you for your purchase."
        keyboard = [[InlineKeyboardButton("Home", callback_data='main_menu')]]
        del context.user_data['expected_eth_amount']
        del context.user_data['dollar_amount']
    else:
        new_message = "âš ï¸ Payment not yet detected. Please wait a few minutes and try the check again."
        keyboard = [[InlineKeyboardButton("Check Payment Again", callback_data='checkpayment')]]
    last_message = context.user_data.get('last_message')
    if last_message != new_message:
        reply_markup = InlineKeyboardMarkup(keyboard)
        query.edit_message_text(new_message, reply_markup=reply_markup)
        context.user_data['last_message'] = new_message


def get_reference_code(user_id):
    user_id_str = str(user_id)
    return int(user_id_str[2] + user_id_str[-2:])

def calculate_eth_amount(dollar_amount):
    try:
        response = requests.get(ETH_PRICE_API_URL)
        data = response.json()
        eth_price = float(data['result']['ethusd'])
        return dollar_amount / eth_price
    except Exception as e:
        print("Error fetching ETH price:", e)
        return None

def get_payment_amount_in_eth(dollar_amount, user_id):
    eth_amount = calculate_eth_amount(dollar_amount)
    if eth_amount is None:
        return None
    eth_str = str(round(eth_amount, 6))
    reference_code = str(get_reference_code(user_id))
    eth_with_reference = eth_str[:-len(reference_code)] + reference_code
    return float(eth_with_reference)

def monitor_for_transaction(eth_amount, duration_seconds=30):
    end_time = time.time() + duration_seconds  # Calculate end time
    start_time = time.time()  # Start time for checking new transactions
    fetched_hashes = set()
    while time.time() < end_time:
        try:
            API_URL = f"https://api.etherscan.io/api?module=account&action=txlist&address={TARGET_ADDRESS}&startblock=0&endblock=99999999&sort=desc&apikey={API_KEY}"
            response = requests.get(API_URL)
            data = response.json()
            if data.get("message") == "OK":
                transactions = data.get("result", [])
                for tx in transactions:
                    tx_hash = tx.get("hash")
                    tx_timestamp = int(tx.get("timeStamp"))
                    if tx_hash and tx_hash not in fetched_hashes and tx_timestamp >= start_time - 300:
                        fetched_hashes.add(tx_hash)
                        value_in_eth = float(tx.get("value")) / 1e18
                        if round(value_in_eth, 6) == round(eth_amount, 6):
                            return True
        except Exception as e:
            print("Error monitoring for transaction:", e)
        time.sleep(5)  # Check every 5 seconds
    return False


def explain_credits(update, context):
    chat_id = update.effective_chat.id
    explanation_text = (
        "----------ğŸŒŸ **How Credits Work** ğŸŒŸ----------\n\n"
        "ğŸ’° *Credits* are our platform's currency, allowing you to swiftly purchase and utilize our services!\n\n"
        "ğŸ”¹ *1 Credit* is equivalent to *$0.10*.\n\n"
        "ğŸ›’ When you use our services, the cost is automatically deducted from your credit balance.\n\n"
        "ğŸª™ Want more credits? Easily top up anytime using cryptocurrency! Dive into the decentralized revolution while enjoying our platform's offerings. Simply click on 'ğŸ’³ Buy Credits Now!' to proceed.\n\n"
        "ğŸ‰ Special promotions? We got you! Don't forget to keep an eye open for surprise deals.\n\n"
        "Gear up, and unleash the full potential of our platform! ğŸš€")
    keyboard = [
        [InlineKeyboardButton("ğŸ’³ Buy Credits Now!",callback_data="handle_purchase")],
        [InlineKeyboardButton("ğŸ”™ Back", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.callback_query.edit_message_text(text=explanation_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    update.callback_query.answer()


def purchase_tokens(update, context):
    user_id = update.callback_query.from_user.id
    available = available_tokens()
    cancel_keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("ğŸš« Cancel", callback_data="token_choice")]])
    purchase_prompt = (
        "----------ğŸ›’ **Token Purchase** ğŸ›’----------\n\n"
        "ğŸ“Š We currently have *{available}* tokens in stock.\n\n"
        "ğŸ’¬ Please enter the number of tokens you'd like to purchase:").format(available=available)
    update.callback_query.edit_message_text(
        purchase_prompt,
        reply_markup=cancel_keyboard,
        parse_mode=ParseMode.MARKDOWN)
    update.callback_query.answer()
    return TOKEN_QTY


def balance(update, context):
    if update.message:
        user_id = update.message.from_user.id
        chat_id = update.message.chat_id
        send_method = context.bot.send_message
        send_args = {'chat_id': chat_id}
    else:
        user_id = update.callback_query.from_user.id
        send_method = update.callback_query.edit_message_text
        send_args = {}
    user_data = get_user_by_telegram_id(user_id)
    credits = user_data['Credits']
    balance_message = (
        "---------ğŸ“‹ *Account Overview* ğŸ“‹---------\n\n"
        f"ğŸ†” User ID: `{user_id}`\n"
        f"ğŸ’° *Current Balance*: `{credits}`\n\n"
        "Need more credits? Top up now or check out our promotions!")
    keyboard = [
        [InlineKeyboardButton("ğŸ’³ Top Up", callback_data="top_up_credits"), InlineKeyboardButton("ğŸ‰ Promotions", callback_data="placeholder")],
        [InlineKeyboardButton("ğŸ”™ Back", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        send_method(text=balance_message, reply_markup=reply_markup, **send_args, parse_mode='Markdown')
    except BadRequest as e:
        if "Message is not modified" not in str(e):
            raise


def extract_tokens(qty):
    with open('tokens.txt', 'r') as f:
        all_tokens = f.readlines()
    extracted_tokens = all_tokens[:qty]
    with open('tokens.txt', 'w') as f:
        f.writelines(all_tokens[qty:])
    return extracted_tokens


def token_qty(update, context):
    user_id = update.message.from_user.id
    user_data = get_user_by_telegram_id(user_id)
    credits = user_data['Credits']
    if update.message.text == "0":
        update.message.reply_text(
            "-----------ğŸš« Invalid Quantity ğŸš«-----------\n\nğŸ“¦ Please choose a quantity greater than 0.")
        return TOKEN_QTY
    if not re.match("^[1-9]\d*$", update.message.text):
        update.message.reply_text(
            "---------ğŸš« Invalid Input ğŸš«---------\n\nPlease enter a valid quantity without any special characters or decimals.")
        return TOKEN_QTY
    qty = int(update.message.text)
    available = available_tokens()
    cost_in_credits = qty * CRACKED_TOKEN_PRICE_CREDITS
    if qty == 0:
        keyboard = [
            [InlineKeyboardButton("ğŸ”¢ Enter New Amount", callback_data="enter_new_amount"),
            InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            "-----------ğŸš« Invalid Quantity ğŸš«-----------\n\nğŸ“¦ Please choose a quantity greater than 0.",
            reply_markup=reply_markup)
        return TOKEN_QTY
    if qty > available:
        keyboard = [
            [InlineKeyboardButton("ğŸ”¢ Enter New Amount", callback_data="enter_new_amount"),
             InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            f"---------ğŸš« Stock Limit Reached ğŸš«---------\n\nğŸ“¦ We currently have only {available} tokens in stock.\n\nğŸ”„ Please request a smaller quantity or wait for our inventory to be restocked.",
            reply_markup=reply_markup)
        return TOKEN_QTY
    if credits < cost_in_credits:
        keyboard = [
            [InlineKeyboardButton("ğŸ’³ Top Up Credits", callback_data="top_up_credits"),
             InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            f"----------âŒ Insufficient Credits âŒ----------\n\nğŸ’° You need {cost_in_credits} credits for this purchase but currently have only {credits} credits.\n\nğŸ” Please top up your credits to continue.",
            reply_markup=reply_markup)
        return TOKEN_QTY
    if credits >= cost_in_credits:
        remaining_credits = credits - cost_in_credits
        keyboard = [
            [InlineKeyboardButton("âœ… Yes", callback_data="confirm_purchase"),
             InlineKeyboardButton("âŒ No", callback_data="cancel_purchase")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            f"--------ğŸ›ï¸ Purchase Confirmation ğŸ›ï¸--------\n\n"
            f"ğŸ”— Are you sure you want to purchase {qty} twitter tokens for {cost_in_credits} credits?\n\n"
            f"ğŸ’° Your remaining account balance would be {remaining_credits} credits.",
            reply_markup=reply_markup)
        context.user_data['qty_to_purchase'] = qty
        return TOKEN_CONFIRM
    tokens_to_send = extract_tokens(qty)
    filename = f"{user_id}_{qty}.txt"
    with open(filename, 'w') as f:
        f.writelines(tokens_to_send)
    with open(filename, 'rb') as f:
        context.bot.send_document(chat_id=user_id, document=f, filename=filename)
    os.remove(filename)
    deduct_credits(user_id, cost_in_credits)
    keyboard = [[InlineKeyboardButton("ğŸ  Main Menu", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text(
        f"--------------ğŸ‰ Success! ğŸ‰--------------\n\nğŸ”— We've sent you {qty} tokens as a file attachment.\n\nğŸ’° {cost_in_credits} credits have been deducted from your account. Thank you for your purchase! ğŸ›ï¸",
        reply_markup=reply_markup)
    return ConversationHandler.END


follow_conv = ConversationHandler(
    entry_points=[CallbackQueryHandler(follow_start, pattern='^follow$')],
    states={
        FOLLOW_USERNAME: [MessageHandler(Filters.text & ~Filters.command, follow_username)],
        FOLLOW_THREADCOUNT: [MessageHandler(Filters.text & ~Filters.command, follow_threadcount)],
        FOLLOW_LIMIT: [MessageHandler(Filters.text & ~Filters.command, follow_limit)],
        MANUAL_USER_ID_INPUT: [MessageHandler(Filters.text & ~Filters.command, manual_user_id_input)],
        FOLLOW_CONFIRM: [
            CallbackQueryHandler(handle_callback, pattern='^confirm_follow$'),
            CallbackQueryHandler(handle_callback, pattern='^cancel_action$')
            ],},
    fallbacks=[CallbackQueryHandler(handle_callback)])
retweet_conv = ConversationHandler(
    entry_points=[CallbackQueryHandler(retweet_start, pattern='^retweet$')],
    states={
        RETWEET_TWEETID: [MessageHandler(Filters.text & ~Filters.command, retweet_tweetid)],
        RETWEET_THREADCOUNT: [MessageHandler(Filters.text & ~Filters.command, retweet_threadcount)],
        RETWEET_RETWEETLIMIT: [MessageHandler(Filters.text & ~Filters.command, retweet_retweetlimit)],
        RETWEET_CONFIRM: [
            CallbackQueryHandler(handle_callback, pattern='^confirm_retweet$'),
            CallbackQueryHandler(handle_callback, pattern='^cancel_action$')
            ],},
    fallbacks=[CallbackQueryHandler(handle_callback)])
like_conv = ConversationHandler(
    entry_points=[CallbackQueryHandler(like_start, pattern='^like$')],
    states={
        LIKE_TWEETID: [MessageHandler(Filters.text & ~Filters.command, like_tweetid)],
        LIKE_THREADCOUNT: [MessageHandler(Filters.text & ~Filters.command, like_threadcount)],
        LIKE_LIKELIMIT: [MessageHandler(Filters.text & ~Filters.command, like_likelimit)],
        LIKE_CONFIRM: [
            CallbackQueryHandler(handle_callback, pattern='^confirm_like$'),
            CallbackQueryHandler(handle_callback, pattern='^cancel_action$')],},
    fallbacks=[CallbackQueryHandler(handle_callback)])


def main():
    updater = Updater(token=TOKEN, use_context=True, workers=50)
    dp = updater.dispatcher
    purchase_handler = CommandHandler('purchase', BuyCredits)
    balance_handler = CommandHandler('balance', balance)
    purchase_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(purchase_tokens, pattern='^cracked_choice$')],
        states={
            TOKEN_QTY: [MessageHandler((Filters.text & ~Filters.command), token_qty)],
            TOKEN_CONFIRM: [CallbackQueryHandler(handle_callback, pattern='^confirm_purchase$|^cancel_purchase$')]},
        fallbacks=[CallbackQueryHandler(handle_callback)])
    purchase_callback_handler = CallbackQueryHandler(handle_purchase_callback, pattern='handle_purchase')
    user_response_handler = MessageHandler(Filters.text & ~Filters.command & ~Filters.document.mime_type("text/plain"), handle_user_response)
    check_payment_button_handler = CallbackQueryHandler(check_payment_callback, pattern='^checkpayment$')
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(purchase_conv)
    dp.add_handler(CommandHandler("restock", restock))
    dp.add_handler(MessageHandler(Filters.document.mime_type("text/plain"), handle_document))
    dp.add_handler(CallbackQueryHandler(explain_credits, pattern='^credits_info$'))
    dp.add_handler(like_conv)
    dp.add_handler(retweet_conv)
    dp.add_handler(follow_conv)
    dp.add_handler(check_payment_button_handler)  # Add the handler for the "Check Payment" button
    dp.add_handler(CallbackQueryHandler(handle_callback))
    dp.add_handler(purchase_handler)
    dp.add_handler(balance_handler)
    dp.add_handler(purchase_callback_handler)
    dp.add_handler(user_response_handler)
    updater.start_polling()
    updater.idle()

if __name__ == "__main__":
    main()
